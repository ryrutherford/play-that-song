{"version":3,"sources":["components/songRequests/RequestSong.js","img/spotify.png","store/actions/songActions.js","components/layout/SignedInLinks.js","store/actions/authActions.js","components/layout/SignedOutLinks.js","components/layout/Navbar.js","components/dashboard/About.js","components/auth/SignIn.js","components/auth/SignUp.js","components/dashboard/Notifications.js","components/sessions/Sessions.js","store/actions/sessionActions.js","components/songRequests/SongRequestSummary.js","components/songRequests/SongRequestList.js","components/sessions/ActiveSession.js","App.js","serviceWorker.js","store/reducers/authReducer.js","store/reducers/songReducer.js","store/reducers/sessionReducer.js","store/reducers/rootReducer.js","config/fbConfig.js","index.js"],"names":["RequestSong","state","songs","isValidURL","props","songRequestSessions","sessionID","sessionExists","isLoaded","i","session","parseInt","handleChange","e","setState","target","id","value","request","require","authOptions","url","headers","Buffer","client_id","toString","form","grant_type","json","post","error","response","body","statusCode","token","access_token","options","encodeURIComponent","query","get","tracks","items","handleClick","requestSong","deleteNotifications","preventDefault","songID","parentNode","document","getElementById","filter","song","history","this","auth","reqError","uid","to","songList","length","map","className","key","src","album","images","alt","SPOTIFY","name","artists","artist","join","rel","title","href","external_urls","spotify","onClick","type","onChange","placeholder","clearError","Component","compose","connect","ownProps","match","params","session_id","firebase","firestore","data","dispatch","firestoreConnect","collection","module","exports","getState","getFirebase","getFirestore","numRequests","docID","requestorID","requestors","alreadyRequested","songIndex","songRequests","where","then","querySnapshot","forEach","doc","songRequest","index","includes","push","externalURL","albumIMGURL","update","catch","err","orderBy","numNotifs","size","delete","undoRequest","userID","splice","createSongRequestFromDashboard","signOut","profile","initials","SignedOutLinks","links","About","SignIn","email","password","handleSubmit","signIn","authError","onSubmit","htmlFor","credentials","signInWithEmailAndPassword","SignUp","firstName","lastName","signUp","required","newUser","createUserWithEmailAndPassword","user","set","Notifications","notifications","item","replace","moment","time","toDate","fromNow","Sessions","joinSessionError","path","getSessions","sessionArr","creatorID","joinSession","elements","newSession","createSession","Math","floor","random","tryAgain","deleteSession","ordered","add","limit","SongRequestList","slice","sort","a","b","ActiveSession","returnSongRequests","App","exact","component","Boolean","window","location","hostname","initState","authReducer","action","message","songReducer","sessError","sessionIDs","sessionReducer","rootReducer","combineReducers","firestoreReducer","firebaseReducer","initializeApp","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","measurementId","analytics","store","createStore","applyMiddleware","thunk","withExtraArgument","reduxFirestore","fbConfig","rrfProps","config","userProfile","useFirestoreForProfile","enableRedirectHandling","resetBeforeLogin","createFirestoreInstance","ReactDOM","render","children","useSelector","navigator","serviceWorker","ready","registration","unregister","console"],"mappings":"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","file":"static/js/main.558e64ad.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport SPOTIFY from 'C:/Users/Ry Rutherford/Documents/JavaScript Projects/Dev/play-that-song/src/img/spotify.png';\r\nimport {requestSong, clearError, deleteNotifications} from '../../store/actions/songActions';\r\nimport {connect} from 'react-redux';\r\nimport {Redirect} from 'react-router-dom';\r\nimport {firestoreConnect, isLoaded} from 'react-redux-firebase';\r\nimport {compose} from 'redux';\r\n\r\nclass RequestSong extends Component {\r\n  state = {\r\n    songs: []\r\n  }\r\n\r\n  //checks whether the url entered is valid (i.e. session_id param in url corresponds to a valid session)\r\n  isValidURL = () => {\r\n    /*\r\n    * songRequestSessions contains data corresponding to all active sessions\r\n    * sessionID corresponds to the sessionID entered (i.e. the sessionID in the URL)\r\n    */\r\n    const {songRequestSessions, sessionID} = this.props;\r\n\r\n    let sessionExists = false;\r\n    //once the songRequestSessions are loaded we can check whether the sessionID exists or not\r\n    if(isLoaded(songRequestSessions)){\r\n      for(let i in songRequestSessions){\r\n        if(songRequestSessions[i].session.sessionID === parseInt(sessionID)){\r\n          sessionExists = true;\r\n          break;\r\n        }\r\n      }\r\n      if(!sessionExists){\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //event handler that manages Spotify API authorization and fetches song data using the Spotify API Search Endpoint\r\n  //the song data is fetched based on what is typed into the form field by the user\r\n  handleChange = (e) => {\r\n    //e.target.id will always = \"query\" in this function\r\n    //after something is typed in the form field, query is updated with the value that was typed\r\n    this.setState({\r\n      [e.target.id]: e.target.value,\r\n    });\r\n\r\n    //SPOTIFY API AUTHORIZATION AND SEARCH ENDPOINT REQUEST\r\n    let request = require('request'); // \"Request\" library\r\n\r\n    let client_id = process.env.REACT_APP_SPOTIFY_CLIENT_ID;\r\n    let client_secret = process.env.REACT_APP_SPOTIFY_CLIENT_SECRET;\r\n    // your application requests authorization\r\n    let authOptions = {\r\n      url: 'https://accounts.spotify.com/api/token',\r\n      headers: {\r\n        'Authorization': 'Basic ' + (new Buffer(client_id + ':' + client_secret).toString('base64'))\r\n      },\r\n      form: {\r\n        grant_type: 'client_credentials'\r\n      },\r\n      json: true\r\n    };\r\n\r\n    //using the input of the user to search spotify for matching songs\r\n    if(e.target.value){\r\n      //authorizing the request\r\n      request.post(authOptions, (error, response, body) => {\r\n        //if authorization succeeded then we can search for songs\r\n        if (!error && response.statusCode === 200) {\r\n\r\n          // use the access token to access the Spotify Web API\r\n          var token = body.access_token;\r\n\r\n          //I decided to only return 5 results but could return more\r\n          var options = {\r\n            url: 'https://api.spotify.com/v1/search?limit=5&q=' + encodeURIComponent(this.state.query) + '&type=track',\r\n            headers: {\r\n              'Authorization': 'Bearer ' + token\r\n            },\r\n            json: true\r\n          };\r\n\r\n          //getting the top 5 search results from Spotify for the value entered by the user\r\n          //once the results are retrieved we update the songs array in the state with the relevant data\r\n          request.get(options, (error, response, body) => {\r\n            this.setState({\r\n              songs: body.tracks.items\r\n            })\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  //click handler that is called when a user wants to request a particular song\r\n  handleClick = (e) => {\r\n    /*\r\n    * requestSong: action creator that will attempt to request the selected song for the current user\r\n    * deleteNotifications: actionCreator that will delete notifications once the notifications collection has > 500 documents\r\n    * sessionID: the current sessionID, needed for the requestSong function\r\n    */\r\n    const {requestSong, deleteNotifications, sessionID} = this.props;\r\n\r\n    e.preventDefault();\r\n\r\n    //the songID is used to select a song from the songs array in state\r\n    const songID = e.target.parentNode.parentNode.parentNode.id;\r\n\r\n    //resetting the value entered by the user to the empty string\r\n    document.getElementById('query').value='';\r\n\r\n    //selecting the song that was requested by the user based on its ID\r\n    const songSelected = this.state.songs.filter(song => song.id === songID);\r\n\r\n    //calling the requestSong action creator with the songSelected, sessionID, and history as params\r\n    //the history is used to redirect the user after the request is complete\r\n    requestSong({songs: songSelected}, this.props.history, sessionID);\r\n\r\n    //deleteNotifications is called everytime a song is requested but will only do anything when there are more than 500 notifications\r\n    deleteNotifications();\r\n\r\n    //updating the state to reflect the attempted (successful or unsuccessful) request\r\n    this.setState({\r\n      songs: []\r\n    });\r\n  }\r\n\r\n  render() {\r\n    /*\r\n    * songRequestSessions contains data corresponding to all active sessions\r\n    * auth contains user data (UID)\r\n    * reqError contains request error data (i.e. if the user tried to a request a song they've already requested)\r\n    */\r\n    const {auth, reqError, songRequestSessions} = this.props;\r\n\r\n    //if auth.uid is undefined then we will redirect the user to the sign in page\r\n    if (!auth.uid){\r\n      return <Redirect to=\"/signin\"/>\r\n    }\r\n\r\n    //if the songRequestSessions are loaded then we can check if the url (sessio_id) is valid\r\n    //if the url is not valid (session with session_id doesn't exist) then we redirect the user to the sessions page\r\n    if(isLoaded(songRequestSessions) && this.isValidURL() === false){\r\n      return <Redirect to='/sessions'/>\r\n    }\r\n\r\n    //the songs returned by the Spotify API\r\n    const songs = this.state.songs;\r\n\r\n    //if there are any songs returned then we map each song in the songs array to a jsx card and assign it to songList\r\n    //otherwise songList is null\r\n    //the resulting songList is displayed in the returned jsx\r\n    const songList = songs.length ? (\r\n      songs.map((song) => {\r\n        return (\r\n          <div className=\"create-requests card\" id={song.id} key={song.id}>\r\n            <div className=\"song-with-album\"><img src={song.album.images[0].url} alt=\"Album Cover\"/></div>\r\n            <div className=\"spotify\"><img src={SPOTIFY} alt=\"Spotify Logo\"/></div>\r\n            <div className=\"card-content\">\r\n              <span className=\"card-title green-text\">{song.name}</span>\r\n              <p className=\"black-text\">{\"Song • \" + song.artists.map(artist => artist.name).join(\", \")}</p>\r\n              <p className=\"green-text\">\r\n                <a target=\"_blank\" rel=\"noreferrer noopener\" title=\"Play on Spotify\" href={song.external_urls.spotify}>Play On Spotify</a>\r\n              </p>\r\n              <div className=\"input-field\">\r\n                <button onClick={this.handleClick} className=\"btn green lighten-1 z-depth-0\">Request Song</button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )\r\n      })\r\n    ) : (null);\r\n\r\n    return (\r\n      <div className=\"container\">\r\n        <form className=\"white\">\r\n          <h5 className=\"black-text text-darken-3\">Search Songs</h5>\r\n          <div className=\"input-field green-text\">\r\n            <input type=\"text\" id=\"query\" onChange={this.handleChange} placeholder=\"Search by song name to display results\"/>\r\n          </div>\r\n          {songList}\r\n        </form>\r\n        {/* If there is a request error (i.e. requesting a song you've already requested) we display a pop up error*/}\r\n        {reqError ? \r\n        (<div className=\"msg-container\">\r\n          <div className=\"msg msg-error z-depth-3 scale-transition center\">\r\n            <p>{reqError}</p>\r\n            {/* When the user acknowledges the error, we use the clearError action creator to remove the error */}\r\n            <button onClick={this.props.clearError} className=\"btn white red-text lighten-1 z-depth-0\">OK</button>\r\n          </div>\r\n         </div>) : (null)}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n//selecting the auth data from firebase, reqErro from the store, and songRequestSessions data from firestore\r\n//the sessionId comes from the ownProps (the session_id field of the URL)\r\nconst mapStateToProps = (state, ownProps) => {\r\n  let sessionID = ownProps.match.params.session_id;\r\n  return {\r\n    auth: state.firebase.auth,\r\n    reqError: state.song.reqError,\r\n    songRequestSessions: state.firestore.data.songRequestSessions,\r\n    sessionID\r\n  }\r\n}\r\n\r\n//mapping dispatch functions to props\r\nconst mapDispatchToProps = (dispatch) => {\r\n  /*\r\n  * requestSong: calls an action creator that will create/update a song request for the session (as long as the user hasn't already requested the song)\r\n  * clearError: calls an action creator that will remove the reqError when a user attempts to request a song they've already requested\r\n  * deleteNotifications: calls an action creator that will delete all notifications except for the 10 most recent ones once the number of notifications exceeds 500\r\n  */\r\n  return {\r\n    requestSong: (songs, history, sessionID) => {\r\n      dispatch(requestSong(songs, history, sessionID));\r\n    },\r\n    clearError: () => {\r\n      dispatch(clearError());\r\n    },\r\n    deleteNotifications: () => {\r\n      dispatch(deleteNotifications());\r\n    }\r\n  }\r\n}\r\n\r\nexport default compose(\r\n  connect(mapStateToProps, mapDispatchToProps),\r\n  firestoreConnect([{collection: 'songRequestSessions'}]))\r\n  (RequestSong)\r\n","module.exports = __webpack_public_path__ + \"static/media/spotify.a162f1ee.png\";","export const requestSong = (songs, history, sessionID) => {\r\n  return (dispatch, getState, {getFirebase, getFirestore}) => {\r\n    \r\n    /*\r\n      firestore: a constant that is connected to the firestore database\r\n      song: a constant that represents the song that was requested by a user\r\n      numRequests: a variable that represents how many times the song has been requested\r\n      docID: the id of the document that contains the requested song. It is initially null as the song may not have been requested already\r\n      requestorID: the id of the user that has just requested the song\r\n      requestors: an array of all the users that have requested this song\r\n      alreadyRequested: a boolean that indicates whether the user has already requested this song\r\n    */\r\n   const firestore = getFirestore();\r\n   const song = songs.songs[0];\r\n   let numRequests = 0;\r\n   let docID = null;\r\n   const requestorID = getState().firebase.auth.uid;\r\n   let requestors = [];\r\n   let alreadyRequested = false;\r\n   let songIndex = null;\r\n   let songRequests = null; //used to update the database with the new/updated sr\r\n\r\n   //the first action is to get a document in the collection that has the same songID as the song that was requested\r\n   firestore.collection('songRequestSessions').where(\"session.sessionID\", \"==\", parseInt(sessionID)).get()\r\n     .then((querySnapshot) => {\r\n       querySnapshot.forEach((doc) => {\r\n\r\n         // doc.data() is never undefined for query doc snapshots\r\n         let session = doc.data().session;\r\n         docID = doc.id;\r\n\r\n         //iterating through all the songRequests in the session to find the song request we're looking for\r\n         songRequests = session.songRequests;\r\n         songRequests.forEach((songRequest, index) => {\r\n            if(songRequest.songID === song.id){\r\n              songIndex = index; //used to identify which index in the songRequests array the song is\r\n              numRequests = songRequest.numRequests + 1;\r\n              requestors = songRequest.requestors;\r\n              \r\n              //if the requestors array includes the requestorID => the user can't request this song\r\n              if (requestors.includes(requestorID)) alreadyRequested = true;\r\n            }\r\n         })\r\n       });\r\n     })\r\n     //the next step is to either add a new songRequest to the session.songRequests array (song hasn't been requested yet) or update the numRequests of the existing songRequest\r\n     .then(() => {\r\n       //if the numRequests is 0 then the song hasn't been requested before, we must add a new song to the array\r\n       if (numRequests === 0){\r\n        numRequests = 1;\r\n        //pushing the new song request to the songRequests array that is a copy of the songRequests in the session doc in firestore\r\n        songRequests.push({\r\n          title: song.name,\r\n          artists: song.artists.map(artist => artist.name),\r\n          externalURL: song.external_urls.spotify,\r\n          songID: song.id,\r\n          requestors: [...requestors, requestorID],\r\n          albumIMGURL: song.album.images[0].url,\r\n          numRequests\r\n        })\r\n        //updating the collection to reflect the change to the songRequests\r\n        firestore.collection('songRequestSessions').doc(docID).update({\r\n          \"session.songRequests\": songRequests\r\n        })\r\n        .then(() => {\r\n           history.push(\"/activeSession/\" + sessionID);\r\n           dispatch({type: 'CREATE_SONG_REQUEST', songs});\r\n         }).catch((error) => {\r\n           dispatch({type: 'CREATE_SONG_REQUEST_ERROR', error});\r\n         });\r\n       }\r\n       //if the numRequests is > 0 then the song has already been requested\r\n       //and we must update the doc to reflect the new request as long as the user hasn't already requested the song\r\n       else if (alreadyRequested === false){\r\n         songRequests[songIndex].numRequests = numRequests;\r\n         songRequests[songIndex].requestors = [...requestors, requestorID];\r\n         firestore.collection('songRequestSessions').doc(docID).update({\r\n           \"session.songRequests\": songRequests\r\n         }).then(() => {\r\n           history.push(\"/activeSession/\" + sessionID);\r\n           dispatch({type: 'UPDATE_SONG_REQUEST', songs});\r\n         }).catch((err) => {\r\n           dispatch({type: 'UPDATE_SONG_REQUEST_ERROR', err});\r\n         });\r\n       }\r\n       else {\r\n         //we dispatch an action indicating the the song has already been requested\r\n         let err = 'You have already requested this song.'\r\n         dispatch({type: 'ALREADY_REQUESTED', err});\r\n       }\r\n     })\r\n   .catch((err) => {\r\n     dispatch({type: 'SONG_REQUEST_ERROR', err});\r\n   })\r\n   .catch((err) => {\r\n     dispatch({type: 'GET_DOCUMENT_ERROR', err});\r\n   })\r\n  }\r\n}\r\n\r\n//used to remove the error message from the request page\r\nexport const clearError = () => {\r\n  return (dispatch, getState) => {\r\n    dispatch({type: 'CLEAR_ERROR'});\r\n  }\r\n}\r\n\r\n//deletes notifications from the notifications collection if there are more than 500 docs in the collection\r\nexport const deleteNotifications = () => {\r\n  return (dispatch, getState, {getFirestore}) => {\r\n    \r\n    const firestore = getFirestore();\r\n\r\n    //the notifications will be retrieved ordered in ascending order by data created\r\n    firestore.collection('notifications').orderBy('time').get()\r\n    .then((querySnapshot) => {\r\n      let numNotifs = querySnapshot.size;\r\n\r\n      //used to check if any notifs were deleted and as a counter for deleting notifs\r\n      let i = 0;\r\n\r\n      //if there are more than 500 notifications in the notifications collection we must:\r\n      //delete the oldest notifications until only 5 remain\r\n      if(numNotifs >= 500){\r\n        querySnapshot.forEach((doc) => {\r\n          if(i < numNotifs - 5){\r\n            //deleting the documents\r\n            firestore.collection('notifications').doc(doc.id).delete()\r\n              .then(() => {\r\n                dispatch({type: 'DELETE_NOTIF'});\r\n              })\r\n              .catch((err) => {\r\n                dispatch({type:'DELETE_NOTIF_ERROR', err});\r\n              })\r\n            i++;\r\n          }\r\n        })\r\n      }\r\n      if(i !== 0) dispatch({type: 'DELETE_NOTIF'});\r\n    })\r\n    .catch((err) => {\r\n      dispatch({type: 'DELETE_NOTIF_ERROR', err})\r\n    })\r\n  }\r\n}\r\n\r\n//used to undo a request for a song that a user has already requested\r\nexport const undoRequest = (songID, userID, sessionID) => {\r\n  return (dispatch, getState, {getFirestore}) => {\r\n    /*\r\n      firestore: a constant that is connected to the firestore database\r\n      numRequests: a variable that represents how many times the song has been requested\r\n      docID: the id of the document that contains the requested song. It is initially null as the song may not have been requested already\r\n      requestors: an array of all the users that have requested this song\r\n      songIndex: the index of the song in the songRequests array in the songRequests array of the corresponding session\r\n      songRequests: the list of songRequests for the sessions with sessionID = sessionID\r\n    */\r\n    const firestore = getFirestore();\r\n    let numRequests = 0;\r\n    let docID = null;\r\n    let requestors = [];\r\n    let songIndex = null;\r\n    let songRequests = null;\r\n\r\n    //getting the document corresponding the song request session with sessionID = sessionID\r\n    firestore.collection('songRequestSessions').where(\"session.sessionID\", \"==\", parseInt(sessionID)).get()\r\n      .then((querySnapshot) => {\r\n        querySnapshot.forEach((doc) => {\r\n          \r\n          //getting the session data\r\n          let session = doc.data().session;\r\n          docID = doc.id;\r\n\r\n          //iterating through all the songRequests in the session to find the songRequest we're looking for\r\n          songRequests = session.songRequests;\r\n          songRequests.forEach((songRequest, index) => {\r\n            if(songRequest.songID === songID){\r\n              songIndex = index; //used to identify which index in the songRequests array the song is\r\n              numRequests = songRequest.numRequests;\r\n              requestors = songRequest.requestors;\r\n            }\r\n          })\r\n        });\r\n      })\r\n      //the next step is to either remove the songRequest from the session.songRequests array (song has been requested once) or update the numRequests of the existing songRequest\r\n      .then(() => {\r\n        //if the numRequests is 1 then the song needs to be removed\r\n        if (numRequests === 1){\r\n        \r\n          //removing the song request from the songRequests array that is a copy of the songRequests in the session doc in firestore\r\n        songRequests.splice(songIndex,1);\r\n\r\n        //updating the collection to reflect the change to the songRequests\r\n        firestore.collection('songRequestSessions').doc(docID).update({\r\n          \"session.songRequests\": songRequests\r\n        })\r\n        .then(() => {\r\n            dispatch({type: 'UNDO_SONG_REQUEST'});\r\n          }).catch((error) => {\r\n            dispatch({type: 'UNDO_SONG_REQUEST_ERROR', error});\r\n          });\r\n        }\r\n        //if the numRequests is > 1 then the song has already been requested\r\n        //we must update the doc to reflect the undone request\r\n        else{\r\n          //updating the numRequests\r\n          songRequests[songIndex].numRequests = numRequests - 1;\r\n\r\n          //removing the requestor ID from the list of requestors\r\n          songRequests[songIndex].requestors = requestors.filter(id => id !== userID);\r\n\r\n          //updating the document with the new list of song requests\r\n          firestore.collection('songRequestSessions').doc(docID).update({\r\n            \"session.songRequests\": songRequests\r\n          }).then(() => {\r\n            dispatch({type: 'UNDO_SONG_REQUEST'});\r\n          }).catch((error) => {\r\n            dispatch({type: 'UNDO_SONG_REQUEST_ERROR', error});\r\n          });\r\n        }\r\n      })\r\n    .catch((error) => {\r\n      dispatch({type: 'UNDO_SONG_REQUEST_ERROR', error});\r\n    })\r\n    .catch((error) => {\r\n      dispatch({type: 'GET_DOCUMENT_ERROR', error});\r\n    })\r\n  }\r\n}\r\n\r\n//an action that will create a song request from the dashboard\r\nexport const createSongRequestFromDashboard = (songID, userID, sessionID) => {\r\n  return (dispatch, getState, {getFirebase, getFirestore}) => {\r\n    \r\n    /*\r\n      firestore: a constant that is connected to the firestore database\r\n      numRequests: a variable that represents how many times the song has been requested\r\n      docID: the id of the document that contains the requested song. It is initially null as the song may not have been requested already\r\n      songIndex: the index of the song in the songRequests array in the songRequests array of the corresponding session\r\n      songRequests: the list of songRequests for the sessions with sessionID = sessionID\r\n    */\r\n    const firestore = getFirestore();\r\n    let numRequests = 0;\r\n    let docID = null;\r\n    let songIndex = null;\r\n    let songRequests = null;\r\n\r\n    //getting the document that corresponds to this sessionID\r\n    firestore.collection('songRequestSessions').where(\"session.sessionID\", \"==\", parseInt(sessionID)).get()\r\n      .then((querySnapshot) => {\r\n        querySnapshot.forEach((doc) => {\r\n          let session = doc.data().session;\r\n          docID = doc.id;\r\n          //iterating through all the songRequests in the session to find the songRequest we're looking for\r\n          songRequests = session.songRequests;\r\n          songRequests.forEach((songRequest, index) => {\r\n            if(songRequest.songID === songID){\r\n              songIndex = index;\r\n              numRequests = songRequest.numRequests;\r\n            }\r\n          })\r\n        });\r\n      })\r\n      //the next step is to update the numRequests of the existing songRequest\r\n      .then(() => {\r\n        //updating the numRequests\r\n        songRequests[songIndex].numRequests = numRequests + 1;\r\n\r\n        //adding the requestor ID from the list of requestors\r\n        songRequests[songIndex].requestors.push(userID);\r\n\r\n        //updating the document to reflect the new request\r\n        firestore.collection('songRequestSessions').doc(docID).update({\r\n          \"session.songRequests\": songRequests\r\n        }).then(() => {\r\n          dispatch({type: 'CREATE_SONG_REQUEST'});\r\n        }).catch((error) => {\r\n          dispatch({type: 'CREATE_SONG_REQUEST_ERROR', error});\r\n        });\r\n      })\r\n    .catch((error) => {\r\n      dispatch({type: 'CREATE_SONG_REQUEST_ERROR', error});\r\n    })\r\n    .catch((error) => {\r\n      dispatch({type: 'GET_DOCUMENT_ERROR', error});\r\n    })\r\n    \r\n  }\r\n}","import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\nimport {connect} from 'react-redux';\r\nimport {signOut} from '../../store/actions/authActions';\r\n\r\n//functional component to display signed in links and profile initials\r\nconst SignedInLinks = (props) => {\r\n  return (\r\n    <ul className=\"right\">\r\n      <li><NavLink to='/about'>About</NavLink></li>\r\n      <li><NavLink to='/sessions'>Sessions</NavLink></li>\r\n      {/*eslint-disable-next-line*/}\r\n      <li><a onClick={props.signOut}>Sign Out</a></li>\r\n      <li><NavLink to='/' className='btn btn-floating grey lighten-1'>{props.profile.initials}</NavLink></li>\r\n    </ul>\r\n  );\r\n}\r\n\r\n//mapping a signOut dispatch function to props\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    /*\r\n    * when the user clicks on Sign Out the signOut action creator will be called which will call the firebase signOut function\r\n    * depending on the result of the firebase signOut a success or error action will be dispatched\r\n    */\r\n    signOut: () => dispatch(signOut())\r\n  }\r\n}\r\n\r\nexport default connect(null, mapDispatchToProps)(SignedInLinks)","\r\n//action creator for when a user attempts to sign in\r\nexport const signIn = (credentials) => {\r\n  return (dispatch, getState, {getFirebase}) => {\r\n    const firebase = getFirebase();\r\n\r\n    //using firebase to handle the sign in => dispatch an action based on success or failure\r\n    firebase.auth().signInWithEmailAndPassword(\r\n      credentials.email,\r\n      credentials.password\r\n    ).then(() => {\r\n      dispatch({type: 'SIGNIN_SUCCESS'})\r\n    }).catch((err) => {\r\n      dispatch({type: 'SIGNIN_ERROR', err})\r\n    })\r\n  }\r\n}\r\n\r\n//action creator for when a user attempts to sign out\r\nexport const signOut = () => {\r\n  return (dispatch, getState, {getFirebase}) => {\r\n    const firebase = getFirebase();\r\n\r\n    //using firebase to handle the sign out => dispatch an action based on success or failure\r\n    firebase.auth().signOut().then(() => {\r\n      dispatch({type: 'SIGNOUT_SUCCESS'})\r\n    }).catch( (err) => {\r\n      dispatch({type: 'SIGNOUT_ERROR'})\r\n    })\r\n  }\r\n}\r\n\r\n//action creator to handle new user sign up\r\nexport const signUp = (newUser) => {\r\n  return (dispatch, getState, {getFirebase, getFirestore}) => {\r\n    const firebase = getFirebase();\r\n    const firestore = getFirestore();\r\n    \r\n    //using firebase to create a new user => upon success create a new user record in the Users collection in firestore\r\n    firebase.auth().createUserWithEmailAndPassword(\r\n      newUser.email,\r\n      newUser.password\r\n    ).then((response) => {\r\n      return firestore.collection('users').doc(response.user.uid).set({\r\n        firstName: newUser.firstName,\r\n        lastName: newUser.lastName,\r\n        initials: newUser.firstName[0] + newUser.lastName[0]\r\n      }).then(() => {\r\n        dispatch({type: 'SIGNUP_SUCCESS'})\r\n      }).catch((err) => {\r\n        dispatch({type: 'SIGNUP_ERROR', err})\r\n      })\r\n    }).catch((err) => {\r\n      dispatch({type: 'SIGNUP_ERROR', err})\r\n    })\r\n  }\r\n}","import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\n\r\n//functional component to display Signed Out Links in the navbar\r\nconst SignedOutLinks = () => {\r\n  return (\r\n    <ul className=\"right\">\r\n      <li><NavLink to='/about'>About</NavLink></li>\r\n      <li><NavLink to='/signin'>Sign In</NavLink></li>\r\n      <li><NavLink to='/signup'>Sign Up</NavLink></li>\r\n    </ul>\r\n  );\r\n}\r\n\r\nexport default SignedOutLinks","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\nimport SignedInLinks from './SignedInLinks';\r\nimport SignedOutLinks from './SignedOutLinks';\r\nimport {connect} from 'react-redux';\r\n\r\n//functional component which defines the Navbar based on whether the user is Signed In or Signed Out\r\nconst Navbar = (props) => {\r\n  const {auth, profile} = props;\r\n  //if the user is signed in, auth.uid will exist and we will get the SignedInLinks, otherwise we get SignedOutLinks\r\n  const links = auth.uid ? <SignedInLinks profile={profile}/> : <SignedOutLinks/>;\r\n  return (\r\n    <nav className=\"nav-wrapper green ligthen-1\">\r\n      <div className=\"container\">\r\n          <Link to='/' className=\"brand-logo\">Play That Song</Link>\r\n          {links}\r\n      </div>\r\n    </nav>\r\n  );\r\n}\r\n\r\n//selecting the auth and profile data from the store (and firebase)\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    //the auth object contains the user's UID\r\n    auth: state.firebase.auth,\r\n    //the profile object contains the data to display the User's initials in the Navbar\r\n    profile: state.firebase.profile\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Navbar)","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\n\r\n//Functional component with hardcoded info about the website\r\nconst About = () => {\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"card\">\r\n        <div className=\"card-content break-line\">\r\n          <p className=\"card-title green-text\"><b>What is <i>Play That Song</i>?</b></p>\r\n          <p className=\"black-text\">\r\n            <i>Play That Song</i> is a website that lets the people who play the music know which songs the audience would like to hear.\r\n            Users can create \"Song Request Sessions\" where they can share a unique code that allows other users to add song requests to the session.\r\n          </p>\r\n        </div>\r\n      </div>\r\n      <div className=\"card\">\r\n        <div className=\"card-content about\">\r\n          <p className=\"card-title green-text\"><b>How does it work?</b></p>\r\n          <p className=\"black-text\">\r\n            Once a Song Request Session is created, users with the unique code can make song requests by using the built in search functionality, integrated with the Spotify API\r\n            to return live search results.\r\n            <br/><br/>\r\n            You must <u><b><Link to='/signup' className=\"green-text\">create an account</Link></b></u> before you can use the app.\r\n          </p>\r\n        </div>\r\n      </div>\r\n      <div className=\"card\">\r\n        <div className=\"card-content about\">\r\n          <p className=\"card-title green-text\"><b>What can I do with it?</b></p>\r\n          <p className=\"black-text\">\r\n            Next time you're hosting an event, party or hanging with friends create a Song Request Session so everyone can have a say in what music is played!\r\n          </p>\r\n        </div>\r\n      </div>\r\n      <div className=\"card\">\r\n        <div className=\"card-content about\">\r\n          <p className=\"card-title green-text\"><b>How was this made?</b></p>\r\n          <p className=\"black-text\">\r\n            The code for this project can be found on <b><u><a href=\"https://github.com/ryrutherford/play-that-song\" className=\"green-text\">Github</a></u></b>.\r\n            <br/><br/>\r\n            The website was built using <b>ReactJS</b> with <b>Redux</b> as the central state manager, <b>Firebase</b> as the host, authentication manager, and cloud function manager, and <b>Firestore</b> as the database.\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default About","import React, { Component } from 'react'\r\nimport {connect} from 'react-redux';\r\nimport {signIn} from '../../store/actions/authActions'\r\nimport {Redirect} from 'react-router-dom';\r\n\r\nclass SignIn extends Component {\r\n\r\n  //state updates based on what is typed by the user in the email and password fields\r\n  state = {\r\n    email: '',\r\n    password: ''\r\n  }\r\n\r\n  //function called to update state when the user types in either the email or password field (represented by e.target.id)\r\n  handleChange = (e) => {\r\n    this.setState({\r\n      [e.target.id]: e.target.value\r\n    });\r\n  }\r\n\r\n  //function called when the user submits the form\r\n  handleSubmit = (e) => {\r\n    e.preventDefault();\r\n    //calls the signIn function which will call the signIn action creator\r\n    //the signIn action creator will verify credentials with firebase and dispatch a Success or Error action accordingly\r\n    this.props.signIn(this.state)\r\n  }\r\n\r\n  render() {\r\n    //authError will be empty unless the user submitted invalid credentials\r\n    const {authError, auth} = this.props;\r\n\r\n    //if the user is already signed in, auth.uid will exist => redirect them to the home page (about page)\r\n    if(auth.uid) return <Redirect to=\"/\"/>\r\n    return (\r\n      <div className=\"container\">\r\n        <form onSubmit={this.handleSubmit} className=\"white\">\r\n          <h5 className=\"black-text text-darken-3\">Sign In</h5>\r\n          <div className=\"input-field\">\r\n            <label htmlFor=\"email\" className=\"green-text\">Email</label>\r\n            <input type=\"email\" id=\"email\" onChange={this.handleChange}/>\r\n          </div>\r\n          <div className=\"input-field\">\r\n            <label htmlFor=\"password\" className=\"green-text\">Password</label>\r\n            <input type=\"password\" id=\"password\" onChange={this.handleChange}/>\r\n          </div>\r\n          <div className=\"input-field\">\r\n            <button className=\"btn green lighten-1 z-depth-0\">Sign In</button>\r\n            <div className=\"red-text center\">\r\n              {authError ? <p>{authError}</p> : null}\r\n            </div>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n//selecting the authError and auth data from the store\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    authError: state.auth.authError,\r\n    auth: state.firebase.auth\r\n  }\r\n}\r\n\r\n//mapping a signIn dispatch function to props\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    //forwarding the credentials to the signIn action creator\r\n    signIn: (credentials) => dispatch(signIn(credentials)),\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(SignIn)\r\n","import React, { Component } from 'react';\r\nimport {Redirect} from 'react-router-dom';\r\nimport {connect} from 'react-redux';\r\nimport {signUp} from '../../store/actions/authActions';\r\n\r\nclass SignUp extends Component {\r\n\r\n  //state updates based on what is typed by the user in the respective form fields\r\n  state = {\r\n    email: '',\r\n    password: '',\r\n    firstName: '',\r\n    lastName: ''\r\n  }\r\n\r\n  //function called to update state when the user types in any form field (represented by e.target.id)\r\n  handleChange = (e) => {\r\n    this.setState({\r\n      [e.target.id]: e.target.value\r\n    });\r\n  }\r\n\r\n  //function called when the user submits the form\r\n  handleSubmit = (e) => {\r\n    e.preventDefault();\r\n    /*\r\n    * calls the signUp function which will call the signUp action creator\r\n    * the signUp action creator will verify user data with firebase\r\n    * upon success => a new user document is added to the users collection and a Success action is dispatched\r\n    * upon failure => an Error action is dispatched, authError is updated, and the user returns to this page\r\n    */\r\n    this.props.signUp(this.state);    \r\n  }\r\n\r\n  render() {\r\n    //authError will be empty unless the user submitted invalid credentials\r\n    const {auth, authError} = this.props;\r\n\r\n    //if the user is already signed in they will be redirected to the home page (about page)\r\n    if(auth.uid) return <Redirect to=\"/\"/>\r\n    return (\r\n      <div className=\"container\">\r\n        <form onSubmit={this.handleSubmit} className=\"white\">\r\n          <h5 className=\"black-text text-darken-3\">Sign Up</h5>\r\n          <div className=\"input-field\">\r\n            <label htmlFor=\"email\" className=\"green-text\">Email</label>\r\n            <input type=\"email\" id=\"email\" onChange={this.handleChange} required/>\r\n          </div>\r\n          <div className=\"input-field\">\r\n            <label htmlFor=\"password\" className=\"green-text\">Password</label>\r\n            <input type=\"password\" id=\"password\" onChange={this.handleChange} required/>\r\n          </div>\r\n          <div className=\"input-field\">\r\n            <label htmlFor=\"firstName\" className=\"green-text\">First Name</label>\r\n            <input type=\"text\" id=\"firstName\" onChange={this.handleChange} required/>\r\n          </div>\r\n          <div className=\"input-field\">\r\n            <label htmlFor=\"lastName\" className=\"green-text\">Last Name</label>\r\n            <input type=\"text\" id=\"lastName\" onChange={this.handleChange} required/>\r\n          </div>\r\n          <div className=\"input-field\">\r\n            <button className=\"btn green lighten-1 z-depth-0\">Sign Up</button>\r\n            <div className=\"red-text center\">\r\n              {authError ? <p>{authError}</p> : null}\r\n            </div>\r\n          </div>\r\n        </form>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n//selecting the authError and auth data from the store\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    auth: state.firebase.auth,\r\n    authError: state.auth.authError\r\n  }\r\n}\r\n\r\n//mapping a signUp dispatch function to props\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    //forwarding the user data to the signUp action creator\r\n    signUp: (newUser) => dispatch(signUp(newUser)),\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(SignUp)\r\n","import React from 'react';\r\nimport moment from 'moment';\r\n\r\n/*\r\n* Functional component which displays the latest notifications about song requests\r\n* the notifications are passed down through the props as a list\r\n* each notification is subsequently mapped to a presentable format\r\n*/\r\nconst Notifications = (props) => {\r\n  const {notifications} = props;\r\n  return (\r\n    <div className=\"section\">\r\n      <h3 className=\"green-text\">Notifications</h3>\r\n      <div className=\"card\">\r\n        <div className=\"card-content\">     \r\n          <ul>\r\n            {notifications && notifications.map((item) => {\r\n              return (\r\n                <li key={item.id}>\r\n                  <span className=\"green-text notifications\">\r\n                    <b>{item.title + \" • \" + item.artists.replace(\",\", \", \")}</b>\r\n                    {\" was requested \" + moment(item.time.toDate()).fromNow()}\r\n                  </span>\r\n                  <hr/>\r\n                </li>\r\n              );\r\n            })}\r\n          </ul>\r\n          <span className=\"black-text notifications\"><i>{notifications !== [] ? null : \"No new notifications\"}</i></span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Notifications","import React, { Component } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {firestoreConnect, isLoaded} from 'react-redux-firebase';\r\nimport {compose} from 'redux';\r\nimport {Redirect} from 'react-router-dom';\r\nimport Notifications from '../dashboard/Notifications';\r\nimport {createSession, deleteSession} from '../../store/actions/sessionActions';\r\n\r\n//Class based component that displays all the sessions created by a user, session actions, and notifications\r\nclass Sessions extends Component {\r\n  \r\n  state = {\r\n    joinSessionError: null,\r\n    path: null\r\n  }\r\n  \r\n  //returns the signed in users active sessions\r\n  getSessions = () => {\r\n    /*\r\n    * songRequestSessions contains data corresponding to all active sessions\r\n    * auth contains signedIn user data (UID)\r\n    */\r\n    const {songRequestSessions, auth} = this.props;\r\n\r\n    let sessionArr = [];\r\n    //when the songRequestSessions data has been loaded we can find all the active sessions for this user\r\n    if(isLoaded(songRequestSessions)){\r\n      for(let i in songRequestSessions){\r\n        if(songRequestSessions[i] !== null){\r\n          if(songRequestSessions[i].creatorID === auth.uid){\r\n            sessionArr.push(songRequestSessions[i].session)\r\n          }\r\n        }\r\n      }\r\n      return sessionArr;\r\n    }\r\n  }\r\n\r\n  //function that initiates the joining of a session\r\n  joinSession = (e) => {\r\n    //songRequestSessions contains data corresponding to all active sessions\r\n    const {songRequestSessions} = this.props;\r\n  \r\n    e.preventDefault();\r\n\r\n    //retrieving the sessionID\r\n    let sessionID = e.target.elements[0].value;\r\n\r\n    //once the songRequestSessions are loaded => we can check whether the sessionID entered is valid\r\n    if(isLoaded(songRequestSessions)){\r\n      let sessionExists = false;\r\n      for(let i in songRequestSessions){\r\n        if(songRequestSessions[i].session.sessionID === parseInt(sessionID, 10)){\r\n          sessionExists = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      //if the session was found in songRequestSessions then we will redirect the user to that session\r\n      if(sessionExists){\r\n        let path = \"/activeSession/\" + sessionID;\r\n        this.setState({path});\r\n      }\r\n      //otherwise we will inform them that there was an error\r\n      else{\r\n        this.setState({\r\n          joinSessionError: 'The code you entered did not match an active session. Please try again'\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  //function that creates a new session\r\n  newSession = () => {\r\n    /*\r\n    * songRequestSessions contains data corresponding to all active sessions\r\n    * createSession calls an action creator which tries to create a new session\r\n    */\r\n    const {songRequestSessions, createSession} = this.props;\r\n\r\n    //once the songRequestSessions are loaded we can generate the session accessCode and call the actionCreator\r\n    if(isLoaded(songRequestSessions)){\r\n      //the random sessionID will be the new session's identifier code (6 digit int from 100000 - 999999)\r\n      let sessionID = Math.floor(100000 + Math.random() * 900000);\r\n\r\n      //the sessionID must be unique so we must check whether a session with this randomly generated ID exists already\r\n      let tryAgain = false;\r\n      for(let i in songRequestSessions){\r\n        if(songRequestSessions[i].session.sessionID === sessionID){\r\n          tryAgain = true;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      //if tryAgain is true => a session with this sessionID already exists so we must try again\r\n      while(tryAgain){\r\n        sessionID = Math.floor(100000 + Math.random() * 900000);\r\n        for(let i in songRequestSessions){\r\n          if(songRequestSessions[i].session.sessionID === sessionID){\r\n            tryAgain = true;\r\n          }\r\n          else{\r\n            tryAgain = false;\r\n          }\r\n        }\r\n      }\r\n      //finally we call the createSession action creator which will dispatch a success, or error action depending on the result from firestore\r\n      //the first param is the session creatorID (the current user's UID), the second param is the randomly generated sessionID\r\n      createSession(this.props.auth.uid, sessionID);\r\n    }\r\n  }\r\n\r\n  //code for deleting a session, updates the database and removes the session from firestore\r\n  deleteSession = (e) => {\r\n    e.preventDefault()\r\n    const sessionID = e.target.id;\r\n    this.props.deleteSession(sessionID);\r\n  }\r\n\r\n  render(){\r\n    /*\r\n    * auth contains authentication data (UID in particular)\r\n    * notifications contains a list of the 10 most recent song request notifications from firestore\r\n    */\r\n    const {auth, notifications} = this.props;\r\n\r\n    //if the user is not authenticated then auth.uid will be undefined and we will redirect to the about page\r\n    if(!auth.uid) {\r\n      return <Redirect to='/about'/>;\r\n    }\r\n    /*\r\n    * if the path attribute of the state object is not empty then: \r\n    *   - it means the user has entered a valid sessionID in the Join Session Form\r\n    *   - we must redirect them to that path\r\n    */\r\n    if(this.state.path){\r\n      return <Redirect to={this.state.path}/>;\r\n    }\r\n\r\n    return (\r\n      <div className=\"container\">\r\n        <div className=\"row\">\r\n          <div className=\"col s12 m6\">\r\n            <div className=\"section\">\r\n              <h3 className=\"green-text\">Sessions</h3>\r\n              <div className=\"card\">\r\n                <div className=\"card-content\">\r\n                  <div className=\"session center\">\r\n                    <button onClick={this.newSession} className=\"btn green lighten-1 z-depth-0 \">New Session</button>\r\n                    <br/>\r\n                    <form onSubmit={this.joinSession} className=\"white\">\r\n                      <div className=\"input-field green-text\">\r\n                        <input type=\"number\" id=\"sessionID\" placeholder=\"Enter Session ID (6 digit code)\"/>\r\n                        <button className=\"btn green lighten-1 z-depth-0\">Join Session</button>\r\n                      </div>\r\n                    </form>\r\n                    {this.state.joinSessionError ? <p className=\"red-text\">{this.state.joinSessionError}</p> : null}\r\n                  </div>\r\n                  <h5 className=\"black-text text-darken-3\">Active Sessions</h5>\r\n                  {/* Getting all of the users active sessions and returning them in a presentable format using map \r\n                  * If the user has no active sessions => display this info\r\n                  */}\r\n                  {\r\n                    this.getSessions() && this.getSessions().length !== 0 ? (this.getSessions().map((session) => {\r\n                      return(\r\n                        <div key={session.sessionID}>\r\n                          <span className=\"green-text card-title\"><a href={\"https://play-that-song-fac18.firebaseapp.com/activeSession/\" + session.sessionID}>Session ID: {session.sessionID}</a></span>\r\n                          <button className=\"btn green lighten-1 z-depth-0\" id={session.sessionID} onClick={this.deleteSession}>Delete Session</button>\r\n                          <hr/>\r\n                        </div>\r\n                      )\r\n                    })) : (<p>You don't have any active sessions</p>)\r\n                  }\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"col s12 m5 offset-m1\">\r\n            <Notifications notifications={notifications}/>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n//selecting the auth info, notifications, and songRequestSessions from the store/firestore/firebase\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    auth: state.firebase.auth,\r\n    notifications: state.firestore.ordered.notifications,\r\n    songRequestSessions: state.firestore.data.songRequestSessions\r\n  }\r\n}\r\n\r\n//mapping dispatch functions to props\r\nconst mapDispatchToProps = (dispatch) => {\r\n  /*\r\n  * createSession => creates a new song request session with unique sessionID & adds it to the SongRequestSessions collection in firestore\r\n  * deleteSession => deletes a song request session from the SongRequestSession in firestore, only available to users who have active sessions\r\n  */\r\n  return {\r\n    createSession: (userID, sessionID) => {\r\n      dispatch(createSession(userID, sessionID));\r\n    },\r\n    deleteSession: (sessionID) => {\r\n      dispatch(deleteSession(sessionID));\r\n    }\r\n  }\r\n}\r\n\r\nexport default compose(\r\n  connect(mapStateToProps, mapDispatchToProps),\r\n  firestoreConnect([\r\n    {collection: 'notifications', limit: 10, orderBy: ['time', 'desc']},\r\n    {collection: 'songRequestSessions'}\r\n  ])\r\n)(Sessions)","//action creator that creates a new song request session based on the creatorID (userID) and randomly generated sessionID\r\nexport const createSession = (userID, sessionID) => {\r\n  return (dispatch, getState, {getFirestore}) => {\r\n    const firestore = getFirestore();\r\n\r\n    //adding the new session to firestore and dispatching a success, or failure action based on the result\r\n    firestore.collection('songRequestSessions').add({\r\n      creatorID: userID,\r\n      session: {\r\n        sessionID: sessionID,\r\n        songRequests: []\r\n      }\r\n    })\r\n    .then(() => {\r\n      dispatch({type: \"SESSION_CREATED\"});\r\n    })\r\n    .catch((error) => {\r\n      dispatch({type:\"SESSION_CREATED_ERROR\", error});\r\n    })\r\n  }\r\n}\r\n\r\n//action creator for deleting the session with corresponding sessionID\r\nexport const deleteSession = (sessionID) => {\r\n  return (dispatch, getState, {getFirestore}) => {\r\n    const firestore = getFirestore();\r\n\r\n    //the sessionID must be converted to an int because that's the way it is represented in firestore\r\n    sessionID = parseInt(sessionID, 10);\r\n\r\n    //deleting the session from firestore with the corresponding sessionID and dispatching a success/failur action based on the result\r\n    firestore.collection('songRequestSessions').where(\"session.sessionID\", \"==\", sessionID).get()\r\n      .then((querySnapshot) => {\r\n        querySnapshot.forEach((doc) => {\r\n          firestore.collection('songRequestSessions').doc(doc.id).delete().then(() => {\r\n            dispatch({type:'DELETE_SESSION'});\r\n          }).catch((error) => {\r\n            dispatch({type:'DELETE_SESSION_ERROR', error});\r\n          })\r\n        })\r\n      })\r\n      .catch((error) => {\r\n        dispatch({type:'DELETE_SESSION_ERROR', error});\r\n      })\r\n  }\r\n}","import React from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {undoRequest, createSongRequestFromDashboard, deleteNotifications} from '../../store/actions/songActions';\r\n\r\n//functional component that displays a card with data about an individual song request\r\n//NOTE: I am currently not using the creatorID but it may prove useful in future versions\r\nconst SongRequestSummary = ({auth, song, creatorID, sessionID, undoRequest, createSongRequestFromDashboard, deleteNotifications}) => {\r\n\r\n  //event handler that will call the undoRequest action creator\r\n  //function will be triggered when a user who has already requested a song in a session clicks \"Undo Request\"\r\n  const handleClickUndo = (e) => {\r\n    e.preventDefault();\r\n    undoRequest(e.target.id, auth.uid, sessionID); //first param is the songID, second is the user id\r\n  }\r\n\r\n  //event handler that will call the createSongRequestFromDashboard action creator and deleteNotifications action creator\r\n  //the deleteNotifications action creator is called to make sure the Notifications collection in firestore doesn't exceed storage limits\r\n  const handleClickRequest = (e) => {\r\n    e.preventDefault();\r\n    createSongRequestFromDashboard(e.target.id, auth.uid, sessionID);\r\n    deleteNotifications();\r\n  }\r\n\r\n  return (\r\n    <div className=\"song-with-album card\" id={song.id} key={song.id}>\r\n    <img src={song.albumIMGURL} alt=\"Album Cover\"/>\r\n    <div className=\"card-content\">\r\n      {auth.uid === creatorID ? (\r\n            /*eventually add functionality that lets the creator remove song requests*/ \r\n            null\r\n            ) : (\r\n              null\r\n            )\r\n          }\r\n      <span className=\"card-title green-text\">\r\n      <a target=\"_blank\" rel=\"noreferrer noopener\" title=\"Play on Spotify\" href={song.externalURL} className=\"green-text\">{song.title}</a>\r\n      </span>\r\n      <p className=\"black-text\">{\"Song • \" + song.artists.join(\", \")}</p>\r\n      <p className=\"black-text\">\r\n        <b>{song.numRequests === 1 ? (song.numRequests + \" Request\") : (song.numRequests + \" Requests\")}</b>\r\n      </p>\r\n      <div>\r\n        {/* \r\n        * If this song request has been requested by the current user\r\n        *   Display an undo request button if they change their mind\r\n        * Otherwise display a Request Song button so they can request the song from the session page\r\n        */}\r\n        {song.requestors.includes(auth.uid) ? (\r\n            <button onClick={handleClickUndo} id={song.songID} className=\"btn red lighten-1 z-depth-0\">Undo Request</button>\r\n          ) : (\r\n            <button onClick={handleClickRequest} id={song.songID} className=\"btn green lighten-1 z-depth-0\">Request Song</button> \r\n          )\r\n        }\r\n      </div>\r\n    </div>\r\n  </div>\r\n  );\r\n}\r\n\r\n//selecting the auth data from the store\r\n//NOTE: I am currently not using this data; however, it may prove useful in future updates\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    auth: state.firebase.auth,\r\n  }\r\n}\r\n\r\n//mapping some dispatch functions to props\r\nconst mapDispatchToProps = (dispatch) => {\r\n  /* \r\n  * createSongRequestFromDashboard: calls an action creator that will update the number of requests a song in a particular session has (using firestore)\r\n  * undoRequest: calls an action creator that will update the number of requests (or delete a request) for a song in a particular session (using firestore)\r\n  * deleteNotifications: calls an action creator that will delete all notifications except for the 10 most recent ones once the number of notifications exceeds 500\r\n  */\r\n  return {\r\n    createSongRequestFromDashboard: (songID, userID, sessionID) => {\r\n      dispatch(createSongRequestFromDashboard(songID, userID, sessionID));\r\n    },\r\n    undoRequest: (songID, userID, sessionID) => {\r\n      dispatch(undoRequest(songID, userID, sessionID))\r\n    },\r\n    deleteNotifications: () => {\r\n      dispatch(deleteNotifications());\r\n    }\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(SongRequestSummary)","import React from 'react';\r\nimport SongRequestSummary from './SongRequestSummary';\r\n\r\n//functional component that displays a list of song requests ordered by number of requests\r\nconst SongRequestList = ({songs, sessionID, creatorID}) => {\r\n  return (\r\n    <div className=\"sr-list section\">\r\n      {/* If there are song requests: \r\n      * - we sort the list of songs by number of requests (desc order)\r\n      * - return a SongRequestSummary for each one \r\n      * Otherwise => we display a message indicating that there are no song requests yet\r\n      */}\r\n      <h3 className=\"card-title green-text\">Song Requests</h3>\r\n        {songs ? songs.slice().sort(function(a, b){return b.numRequests - a.numRequests}).map(song => {\r\n          return (\r\n            <SongRequestSummary sessionID={sessionID} creatorID={creatorID} song={song} key={sessionID}/>\r\n          );\r\n        }) : (\r\n          <h6 className=\"black-text\"><i>No song requests</i></h6>\r\n        )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SongRequestList","import React, {Component} from 'react';\r\nimport Notifications from '../dashboard//Notifications';\r\nimport SongRequestList from '../songRequests/SongRequestList';\r\nimport {connect} from 'react-redux';\r\nimport {firestoreConnect, isLoaded} from 'react-redux-firebase';\r\nimport {compose} from 'redux';\r\nimport {Redirect} from 'react-router-dom';\r\n\r\nclass ActiveSession extends Component {\r\n\r\n  //this function checks whether the url entered (i.e. access code) exists or not\r\n  //if it doesn't exist, the user is redirected to the sessions page\r\n  isValidURL = () => {\r\n    /*\r\n    * songRequestSessions contains data corresponding to all active sessions\r\n    * sessionID corresponds to the sessionID entered (i.e. the sessionID in the URL)\r\n    */\r\n    const {songRequestSessions, sessionID} = this.props;\r\n\r\n    let sessionExists = false;\r\n    \r\n    //once the songRequestSessions have been loaded we can check if the sessionID exists\r\n    if(isLoaded(songRequestSessions)){\r\n      \r\n      //checking if the sessionID exists\r\n      for(let i in songRequestSessions){\r\n        if(songRequestSessions[i].session.sessionID === parseInt(sessionID)){\r\n          sessionExists = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if(!sessionExists){\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //a function that returns the song requests and creatorID for the corresponding song request session\r\n  //NOTE: I am currently not doing anything with the creatorID but I included it because it may come in handy if I want to add functionality\r\n  returnSongRequests = () => {\r\n    /*\r\n    * songRequestSessions contains data corresponding to all active sessions\r\n    * sessionID corresponds to the sessionID entered (i.e. the sessionID in the URL)\r\n    */\r\n    const {songRequestSessions, sessionID} = this.props;\r\n\r\n    //once the songRequestSessions have been loaded we can get the song requests for that session\r\n    if(isLoaded(songRequestSessions)){\r\n      let songRequests = [];\r\n      let creatorID = null;\r\n\r\n      //retrieving the songRequests, and the creatorID of the songRequestSession\r\n      for(let i in songRequestSessions){\r\n        if(songRequestSessions[i].session.sessionID === parseInt(sessionID)){\r\n          songRequests = songRequestSessions[i].session.songRequests;\r\n          creatorID = songRequestSessions[i].creatorID;\r\n          break;\r\n        }\r\n      }\r\n      return {songRequests, creatorID};\r\n    }\r\n  }\r\n\r\n  render() {\r\n    /*\r\n    * auth contains authentication data (UID in particular)\r\n    * notifications contains a list of the 10 most recent song request notifications from firestore\r\n    * songRequestSessions contains data corresponding to all active sessions (from firestore)\r\n    * sessionID corresponds to the sessionID entered (i.e. the sessionID in the URL)\r\n    */\r\n    const {auth, notifications, sessionID, songRequestSessions} = this.props;\r\n\r\n    //if the user is not signed in => redirect to about page (home page)\r\n    if(!auth.uid) {\r\n      return <Redirect to='/about'/>\r\n    }\r\n\r\n    //if the songRequestSessions have been loaded => we can check if the url is valid\r\n    //if the URL is NOT valid => we redirect the user to the sessions page\r\n    if(isLoaded(songRequestSessions) && this.isValidURL() === false){\r\n      return <Redirect to='/sessions'/>\r\n    }\r\n\r\n    //if the songRequestSessions have been loaded => we display session info, song request info and notifications\r\n    if(isLoaded(songRequestSessions))\r\n      return (\r\n        <div>\r\n          <div className=\"container\">\r\n            <div className=\"card\">\r\n              <div className=\"card-content break-line\">\r\n                <p className=\"card-title green-text center\"><b>Session {sessionID}</b></p>\r\n                <p className=\"black-text center\">Share this code <b>{sessionID}</b> or this link <a href={\"https://play-that-song-fac18.firebaseapp.com/activeSession/\" + sessionID}>{\"https://play-that-song-fac18.firebaseapp.com/activeSession/\" + sessionID}</a> with people to allow them to make requests</p>\r\n                <br/>\r\n                <p className=\"black-text center\">Navigate to <a href={\"https://play-that-song-fac18.firebaseapp.com/activeSession/\" + sessionID}>{\"https://play-that-song-fac18.firebaseapp.com/activeSession/\" + sessionID}</a> to start requesting songs or go to <a href=\"https://play-that-song-fac18.firebaseapp.com/sessions\">https://play-that-song-fac18.firebaseapp.com/sessions</a> to check out your other active sessions</p>\r\n                <div className=\"srButton\">\r\n                  <button onClick={() => this.props.history.push(\"/activeSession/\" + sessionID + \"/createSR\")} className=\"btn green center lighten-1 z-depth-0\">Create Song Request</button>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"container\">\r\n            <div className=\"row\">\r\n              <div className=\"col s12 m6\">\r\n                <SongRequestList sessionID={this.props.sessionID} songs={this.returnSongRequests().songRequests} creatorID={this.returnSongRequests().creatorID}/>\r\n              </div>\r\n              <div className=\"col s12 m5 offset-m1\">\r\n                <Notifications notifications={notifications}/>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      );\r\n      //display a loading circle while the songRequestSessions data is loading\r\n      else {\r\n        return (\r\n          <center>\r\n            <div className=\"preloader-wrapper big active\">\r\n              <div className=\"spinner-layer spinner-green-only\">\r\n                <div className=\"circle-clipper left\">\r\n                  <div className=\"circle\"></div>\r\n                </div><div className=\"gap-patch\">\r\n                  <div className=\"circle\"></div>\r\n                </div><div className=\"circle-clipper right\">\r\n                  <div className=\"circle\"></div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </center>\r\n        )\r\n      }\r\n  }\r\n}\r\n\r\n//selecting the auth data from firebase and notifications + songRequestSessions data from firestore\r\n//the sessionId comes from the ownProps (the session_id field of the URL)\r\nconst mapStateToProps = (state, ownProps) => {\r\n  let sessionID = ownProps.match.params.session_id;\r\n  return {\r\n    auth: state.firebase.auth,\r\n    notifications: state.firestore.ordered.notifications,\r\n    songRequestSessions: state.firestore.data.songRequestSessions,\r\n    sessionID\r\n  }\r\n}\r\n\r\nexport default compose(\r\n  connect(mapStateToProps),\r\n  firestoreConnect([\r\n    {collection: 'notifications', limit: 10, orderBy: ['time', 'desc']},\r\n    {collection: 'songRequestSessions'}\r\n  ])\r\n)(ActiveSession)","import React, { Component } from 'react';\nimport {BrowserRouter, Switch, Route} from 'react-router-dom';\nimport Navbar from './components/layout/Navbar';\nimport About from './components/dashboard/About';\nimport SignIn from './components/auth/SignIn';\nimport SignUp from './components/auth/SignUp';\nimport RequestSong from './components/songRequests/RequestSong';\nimport Sessions from './components/sessions/Sessions';\nimport ActiveSession from './components/sessions/ActiveSession';\n\nclass App extends Component {\n\n  render (){\n    return (\n      <BrowserRouter>\n        <div className=\"App\">\n          <Navbar/>\n          <Switch>\n            <Route exact path=\"/\" component={Sessions}></Route>\n            <Route path=\"/about\" component={About}></Route>\n            <Route path=\"/signin\" component={SignIn}></Route>\n            <Route path=\"/signup\" component={SignUp}></Route>\n            <Route path=\"/sessions\" component={Sessions}></Route>\n            <Route exact path=\"/activeSession/:session_id\" component={ActiveSession}></Route>\n            <Route path=\"/activeSession/:session_id/createSR\" component={RequestSong}></Route>\n          </Switch>\n        </div>\n      </BrowserRouter>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","//initially the authError will be null\r\nconst initState = {\r\n  authError: null\r\n};\r\n\r\nconst authReducer = (state = initState, action) => {\r\n  switch(action.type){\r\n    case 'SIGNIN_ERROR':\r\n      return {\r\n        ...state,\r\n        authError: 'Sign In Failed - Email or Password Incorrect'\r\n      };\r\n    case 'SIGNIN_SUCCESS':\r\n      return {\r\n        ...state,\r\n        authError: null\r\n      }\r\n    case 'SIGNOUT_SUCCESS':\r\n      return state;\r\n    case 'SIGNOUT_ERROR':\r\n      return state;\r\n    case 'SIGNUP_SUCCESS':\r\n      return {\r\n        ...state,\r\n        authError: null\r\n      }\r\n    case 'SIGNUP_ERROR':\r\n      return {\r\n        ...state,\r\n        authError: action.err.message\r\n      }\r\n    case \"CLEAR_ERROR\":\r\n      return {\r\n        ...state,\r\n        authError: null\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nexport default authReducer","//initially the reqError will be null\r\nconst initState = {\r\n  reqError: null\r\n};\r\n\r\nconst songReducer = (state = initState, action) => {\r\n  switch(action.type){\r\n    case 'CREATE_SONG_REQUEST':\r\n      return state;\r\n    case 'CREATE_SONG_REQUEST_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      };\r\n    case 'UPDATE_SONG_REQUEST':\r\n      return state;\r\n    case 'UPDATE_SONG_REQUEST_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      };\r\n    case 'ALREADY_REQUESTED':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      };\r\n    case 'SONG_REQUEST_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      };\r\n    case 'GET_DOCUMENT_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      };\r\n    case 'CLEAR_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: null\r\n      }\r\n    case 'UNDO_SONG_REQUEST':\r\n      return state;\r\n    case 'UNDO_SONG_REQUEST_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      }\r\n    case 'DELETE_NOTIF':\r\n      return state;\r\n    case 'DELETE_NOTIF_ERROR':\r\n      return {\r\n        ...state,\r\n        reqError: action.err\r\n      }\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nexport default songReducer","const initState = {\r\n  sessError: null,\r\n  sessionIDs: []\r\n}\r\nconst sessionReducer = (state = initState, action) => {\r\n  switch(action.type){\r\n    case 'SESSION_CREATED':\r\n      return state;\r\n    case 'SESSION_CREATED_ERROR':\r\n      return {\r\n        ...state,\r\n        sessError: action.error\r\n      }\r\n    case 'DELETE_SESSION':\r\n      return state;\r\n    case 'DELETE_SESSION_ERROR':\r\n      return {\r\n        ...state,\r\n        sessError: action.error\r\n      }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nexport default sessionReducer;","import authReducer from './authReducer';\r\nimport songReducer from './songReducer';\r\nimport sessionReducer from './sessionReducer';\r\nimport {combineReducers} from 'redux';\r\nimport {firestoreReducer} from 'redux-firestore';\r\nimport {firebaseReducer} from 'react-redux-firebase';\r\n\r\n/*\r\n* authReducer: reducer for authentication actions\r\n* songReducer: reducer for song request actions\r\n* sessionReducer: reducer for session actions\r\n* firestoreReducer: reducer for firestore actions\r\n* firebaseReducer: reducer for firebase actions\r\n*/\r\nconst rootReducer = combineReducers({\r\n  auth: authReducer,\r\n  song: songReducer,\r\n  session: sessionReducer,\r\n  firestore: firestoreReducer,\r\n  firebase: firebaseReducer\r\n});\r\n\r\nexport default rootReducer","  import firebase from 'firebase/app';\r\n  import 'firebase/firestore';\r\n  import 'firebase/auth';\r\n  import 'firebase/analytics';\r\n  \r\n  // Your web app's Firebase configuration\r\n  var firebaseConfig = {\r\n    apiKey: \"AIzaSyCiS_fQpcw_1JGpyXgdcb-f7n3U8fOCz2M\",\r\n    authDomain: \"play-that-song-fac18.firebaseapp.com\",\r\n    databaseURL: \"https://play-that-song-fac18.firebaseio.com\",\r\n    projectId: \"play-that-song-fac18\",\r\n    storageBucket: \"play-that-song-fac18.appspot.com\",\r\n    messagingSenderId: \"843690786024\",\r\n    appId: \"1:843690786024:web:dbf48faf223b36c2c39d5d\",\r\n    measurementId: \"G-6092ZKX3KV\"\r\n  };\r\n  // Initialize Firebase\r\n  firebase.initializeApp(firebaseConfig);\r\n  firebase.analytics();\r\n  firebase.firestore();\r\n\r\n  export default firebase;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport rootReducer from './store/reducers/rootReducer'\nimport { Provider, useSelector } from 'react-redux'\nimport thunk from 'redux-thunk'\nimport { createFirestoreInstance, getFirestore, reduxFirestore } from 'redux-firestore'\nimport { ReactReduxFirebaseProvider, getFirebase, isLoaded } from 'react-redux-firebase'\nimport fbConfig from './config/fbConfig'\nimport firebase from 'firebase/app'\n\nconst store = createStore(\n    rootReducer,\n    compose(\n        applyMiddleware(thunk.withExtraArgument({ getFirestore, getFirebase })),\n        reduxFirestore(firebase, fbConfig)\n    )\n);\n\nconst profileSpecificProps = {\n  userProfile: 'users',\n  useFirestoreForProfile: true,\n  enableRedirectHandling: false,\n  resetBeforeLogin: false\n}\n\nconst rrfProps = {\n  firebase,\n  config: fbConfig,\n  // eslint-disable-next-line\n  config: profileSpecificProps,\n  dispatch: store.dispatch,\n  createFirestoreInstance,\n  userProfile: 'users', // where profiles are stored in database\n  presence: 'presence', // where list of online users is stored in database\n  sessions: 'sessions'\n}\n\nfunction AuthIsLoaded({ children }) {\n  const auth = useSelector(state => state.firebase.auth)\n  if (!isLoaded(auth)) return (\n    <center>\n      <div className=\"preloader-wrapper big active\">\n        <div className=\"spinner-layer spinner-green-only\">\n          <div className=\"circle-clipper left\">\n            <div className=\"circle\"></div>\n          </div><div className=\"gap-patch\">\n            <div className=\"circle\"></div>\n          </div><div className=\"circle-clipper right\">\n            <div className=\"circle\"></div>\n          </div>\n        </div>\n      </div>\n    </center>\n  );\n    return children\n}\n\nReactDOM.render(\n<Provider store={store}>\n  <ReactReduxFirebaseProvider {...rrfProps}> \n    <AuthIsLoaded>\n      <App />\n    </AuthIsLoaded>\n  </ReactReduxFirebaseProvider>\n</Provider>,\ndocument.getElementById('root')\n);\n\nserviceWorker.unregister(); "],"sourceRoot":""}